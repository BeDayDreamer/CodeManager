指针传递（productA *self）
void createProductB_1(productA *self);
表示：传递的是一个指针（地址）。
功能：
通过指针可以访问并修改传递对象的实际数据（即修改原始对象的属性）。
使用这种方式，避免了拷贝整个对象，提高了性能（尤其是对于较大的结构体）。

值传递（productA self）
void createProductB_1(productA self);
表示：传递的是对象的值（一个完整的副本）。
功能：
函数内部会创建一个对象副本，对该副本的修改不会影响原始对象。
这种方式会占用更多内存，因为每次调用函数时都会复制整个对象（如果结构体较大，性能开销会更高）。

为什么用指针传递（productA *self）更好？
避免不必要的拷贝：

如果对象是一个大型结构体，传递整个对象（值传递）会导致性能问题，而传递指针（指针传递）只需传递地址，占用内存更少。
能够修改原始对象：

！！！！！！！指针传递允许函数直接修改传递对象的属性，而值传递仅修改副本，无法影响原始对象。
与多态和动态内存管理兼容：

在更复杂的设计中，指针更适合用来实现动态分配和多态（例如，动态分配的对象只能通过指针访问）。
总结
如果函数需要修改传入的对象，应该使用 指针传递 (productA *self)。
如果函数只需要读取对象的值，且不需要修改原始对象，可以使用 值传递 (productA self)。
在实际编程中，特别是处理较大的结构体时，指针传递是更常见、更高效的选择。